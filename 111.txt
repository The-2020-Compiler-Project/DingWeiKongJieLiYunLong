
#include<string>
#include<vector>
#include<iostream>
#include<fstream>
#include<math.h> 
#include<stdio.h>
#define OK 1
#define ERROR 0
using namespace std;
string KT[13] = { "const","int","char","void","main", "if","lese","do","while","for","scanf","printf","return" };
string PT[20] = { "+","-","*","/","<","<=",">",">=","==","!=","=",";","'","(",")","[","]","{","}" };
vector<string>IT;  //关键字表，动态表；
vector<string>CT;  //常数表，动态表
vector<string>cT;  //字符表
vector<string>sT;  //字符串表
string filename;     //文件名
enum stytle { i, c, p, s, C, k };    //分别表示标识符，常数，界符，字符串常量，字符常量,标识符

struct quat
{
	string operate;		//操作符 
	string oper1;		//操作数1 
	string oper2;		//操作数2 
	string result;		//结果 
};		//定义四元式的结构体类型

class Semantic
{
public:
	//Token current;		//表示当前读取的token串 
	//stack<Token>Arithmeticsem;		//语义栈 
	//vector<quat>QuarterList;		//语义分析得到的四元式表 
	//int Arithmetic();		//算术表达式翻译文法
	//void Print_Quat();		//四元式输出
	int Semantic_Run();		//语义分析入口
	//int ComLex();		//复合语句入口 
	//int Variable_Index();	//变量声明子程序 
	//int T();
	//int E1();
	//int F();
	//int T1();

};

class Token
{
public:
	stytle type;              //类码,枚举表示
	string value;            //值
};                            //二元组的设计
class word
{
private:
	fstream myfile;      //定义读取文件的流
	char ch;              //将要读入的下一个字符
	string value;        //当前单词
	Token toke;
public:
	word();                       //进行初始化，打开文件，判断文件是否存在等
	void snapNote();              //跳过注释
	bool isDigtal();              //判断是否是字母
	bool isNumber();              //判断是否是数字
	Token scaner();              //读取一个单词并且生成TOKEN
	bool KeyWord();              //判断是否为关键字
	void toToken(int state);
	void isChar();
	void isString();
	double number();              //生成一个处理机
	~word();
};

word::word()
{
	//filename = "text.cpp";
	char a[100]="text.cpp";
	this->myfile.open(a,ios_base::in | ios_base::out);
	if (!myfile.is_open())
		cout << "ERROR，Can't open the file";

}
void word::snapNote()                    //用有限状态自动机去掉注释
{
	int state = 1;
	int flag=0;
	if (ch == '/')
	{
		state = 2;
		while ((ch = myfile.get()) != EOF)
		{
			switch (state)
			{
			case 2:
				if (ch == '*')
					state = 3;
				else
				{
					state = 1;
					flag = 1;                //准备跳出
					myfile.seekg(-1, ios::cur);      //往前回溯一个
					this->ch = myfile.get();

				}
				break;
			case 3:
				if (ch == '*')
					state = 4;
				break;
			case 4:
				if (ch == '/')              //跳出
					state = 5;
				break;
			case 5:
				flag = 1;
				break;
			}
			if (1 == flag)
				break;
		}
	}
	return;
}
bool word::KeyWord()
{
	for (int i = 0; i < 13; i++)                          //现有13个关键词
	{
		if (KT[i] == value)
			return true;
	}
	return false;
}

void word::toToken(int state)                                   //形成token并返回
{
	switch (state)
	{
	case 1:                                                    //处理标识符和关键字
		if (KeyWord())                                          //是关键字
		{
			this->toke.value = this->value;
			this->toke.type = k;
		}
		else
		{
			this->toke.value = this->value;
			this->toke.type = i;
		}
		break;
	case 2:                                                    //处理界符，直接生成
		this->toke.value = this->value;
		this->toke.type = p;
		break;                                             
	case 3:                                                   //字符串处理
		this->toke.value = this->value;
		this->toke.type = C;
		break;
	case 4:
		this->toke.value = this->value;
		this->toke.type = s;
		break;
	case 5:
		this->toke.value = this->value;
		this->toke.type = c;
		break;

	}
}
bool word::isDigtal()
{
	if (ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z')
		return true;
	return false;
}
bool word::isNumber()
{
	return ch <= '9' && ch >= '0';
	return false;
}
void word::isChar()
{
	ch = myfile.get();
	value += ch;
	toToken(3);
	ch = myfile.get();
	if (ch != '\'')
	{
		cout << "单词有问题";
		exit(0);
	}
}
void word::isString()
{
	while ((ch = myfile.get()) != EOF)
	{
		if (ch != '"')
			value += ch;
		else
			break;
	}
	if (ch != '"')
	{
		cout << "字符串有问题";
		exit(0);
	}
	else
		toToken(4);
}

double word::number()
{
	{
		int n = 0, p = 0, m = 0, t = 0, e = 1;
		double num;
		int a = ch - '0';
		n = 10 * n + a;
		while ((ch = myfile.get()) != EOF)
		{
			int state = 2;
			switch (state)
			{
			case 2:
				if (isNumber())
				{
					a = ch - '0';
					n = 10 * n + a;
					state = 2;
				}
				else if (ch == '.')
				{
					t = 1;
					state = 3;
				}
				else if (ch == 'e')
				{
					t = 1;
					state = 5;
				}
				else
				{
					num = n * pow(10, e * p - m);
					return num;
				}
				break;
			case 3:
				if (isNumber())
				{
					state = 4;
					a = ch - '0';
					n = 10 * n + a;
				}
				else
				{
					cout << "数字拼写错误";
					exit(0);
				}
				break;
			case 4:
				if (isNumber())
				{
					state = 4;
					a = ch - '0';
					n = 10 * n + a;
				}
				else if (ch == 'e')
				{
					t = 1;
					state = 5;
				}
				else	
				{
					num = n * pow(10, e * p - m);
					return num;
				}
				break;
			case 5:
				if (isNumber())
				{
					state = 7;
					a = ch - '0';
					p = 10 * p + a;
				}
				else if (ch== '-')
				{
					state = 6;
					e = -1;
				}
				break;
			case 6:
				if (isNumber())
				{
					state = 7;
					a = ch - '0';
					p = 10 * p + a;
				}
				else
				{
					cout << "数字拼写错误";
					exit(0);
				}
				break;
			case 7:
				if (isNumber())
				{
					state = 7;
					a = ch - '0';
					p = 10 * p + a;
				}
				else
				{
					num = n * pow(10, e * p - m);
					return num;
				}
				break;
			default:
				cout << "ERROR";
				exit(0);
		}
	}
	}

}
Token word::scaner()                        //词法扫描机，形成token
{
	int state;                            //判断生成的类码类型
	this->value.clear();
	if ((ch = myfile.get()) == EOF)
		exit(0);
	else
	{
		snapNote();                        //过滤注释
		while (ch == ' ' || ch == '\n' || ch == '\r')
			ch = myfile.get();           //去掉空格
		if (ch == '_' || isDigtal())     //识别标识符
		{
			this->value += ch;            //进入单词项
			while (ch = myfile.get())        //继续读取
			{
				if (isDigtal() || isNumber())
					this->value += ch;
				else
				{
					state = 1;
					toToken(state);              //token生成函数，与关键字进行匹配
					myfile.seekg(-1, ios::cur);
					return toke;              //识别出单词，直接返回单词
				}
			}
		}
		else if (isNumber())
		{
			double num = number();
			char a[100];
			sprintf(a, "%.3f", num);
			this->value = a;
			myfile.seekg(-1, ios::cur);
			toToken(5);
			return toke;
		}
		else
		{
			state = 2;
			switch (ch)
			{
			case'=':
				value += ch;
				ch = myfile.get();
				if (ch == '=')
				{
					value += ch;
					toToken(state);
				}
				else
				{
				toToken(state);
				myfile.seekg(-1, ios::cur);
				}
				break;
			case '+':
				value += ch;
				ch = myfile.get();
				if (ch == '=')
				{
					value += ch;
					toToken(state);
				}
				else if (ch == '+')
				{
					value += ch;
					toToken(state);
				}
				else
				{
					toToken(state);
					myfile.seekg(-1, ios::cur);
				}
				break;
			case '-':
				value += ch;
				ch = myfile.get();
				if (ch == '=')
				{
					value += ch;
					toToken(state);
				}
				else if (ch == '-')
				{
					value += ch;
					toToken(state);
				}
				else
				{
					toToken(state);
					myfile.seekg(-1, ios::cur);
				}
				break;
			case '*':
			case '/':
			case '<':
			case '>':
			case '!':
				value += ch;
				ch = myfile.get();
				if (ch == '=')
				{
					value += ch;
					toToken(state);
				}
				else
				{
					toToken(state);
					myfile.seekg(-1, ios::cur);
				}
				break;
			case ';':
			case ',':
			case '(':
			case ')':
			case '[':
			case ']':
			case '{':
			case '}':
				value += ch;
				toToken(state);
				break;
			case '\'':
				isChar();
				break;
			case'"':
				isString();
				break;
			default:
				cout << "符号有问题";
				exit(0);
			}
			return toke;
		}
	}
}
word::~word()
{
	myfile.close();
}
int Semantic::Semantic_Run()		//语义分析主程序入口 
{
	Token toke;
	word* p = new word;
	toke = p->scaner();
	if (toke.value == "void")
		toke = p->scaner();
	else
	{
		cout << "主函数返回类型不为void" << endl;
		return ERROR;
	}
	if (toke.value == "main")
		toke = p->scaner();
	else
	{
		cout << "主函数缺少main标识" << endl;
		return ERROR;
	}
	if (toke.value == "(")
		toke = p->scaner();
	else
	{
		cout << "缺少左括号" << endl;
		return ERROR;
	}
	if (toke.value == ")")
		toke = p->scaner();
	else
	{
		cout << "缺少右括号" << endl;
		return ERROR;
	}
	if (toke.value == "{")
		toke = p->scaner();
	else
	{
		cout << "缺少左括号{" << endl;
		return ERROR;
	}
	//ComLex();
	if (toke.value == "}")
		toke = p->scaner();
	else
	{
		cout << "缺少右括号}" << endl;
		return ERROR;
	}
	return OK;
}
int main()
{
	Semantic S;
	S.Semantic_Run();
}

