第一次过程报告——陈雨晗

一、当前进展

1. 文法设计

   ​	经过小组成员们的积极讨论与修改，最终得到的文法如下：

   (1)<程序> --> void main (){ <复合语句> }

   解释：无语义动作，只需要进行关键字和界符的判断，遇到错误当即进行抛出

   (2)<复合语句> --> <类型> <变量声明语句> <复合语句>

   						|| 标识符 <赋值语句> <复合语句>
   	
   						|| <if语句> <复合语句> 
   	
   						|| <while语句> <复合语句>  || 空空

   (3)<类型> --> int || char || bool || string || double

   (4)<变量声明语句> --> 标识符 <变量声明子程序>

   (5) <变量声明子程序> --> <非数组型变量声明语句> ;

   									|| [整型常数] <数组型变量声明语句>

   (6) <非数组型变量声明语句> --> , 标识符 <非数组型变量声明语句> 

   													|| = <表达式> ||空空

   (7) <数组型变量声明语句> --> , 标识符 [算术表达式] <非数组型变量声明语句>

   												|| = { <表达式> <数组初始化> } || = <表达式> || 空空

   (8) <数组初始化> --> , <表达式> <数组初始化> || 空空

   (9) <赋值语句> --> <赋值语句子程序> || [ 算术表达式 ] <赋值语句子程序>

   (10)<赋值语句子程序> -->  = <表达式> ;

   (11)<表达式> --> 算术表达式 || 逻辑表达式 || 字符常量 || 字符串常量

   (12)<逻辑表达式> --> <运算符> <算术表达式>

   (13)<算术表达式> --> > || >= || < || <= || && || || ||== || != || 空空

   (14)<while语句> --> while (表达式) {复合语句} 复合语句

   (15)<if语句> --> if (表达式) {复合语句} <if语句子程序>

   (16)<if语句子程序> --> <复合语句> || else {复合语句} <复合语句>

   (15)<算术表达式> -->TE1

   (16)T->FT1

   (17)E1->W0(+ || -) T E1 || 空

   (18)F->标识符 <B> || (算术表达式) || 常数

   (19)<B>-->[算术表达式]||空空

   (20)T1->W1(* || /) F T1 || 空

2. 负责部分

   ​	在前端部分中，我主要负责的是符号表的设计，符号表底层的设计，活动记录以及符号表的增删查改等维护，另外辅助参与文法的设计和模块的对接。

3. 数据结构

   ​	符号表采用动态链表作为基本数据结构，其每个结点的数据类型是自定义的SymbolTable类，其中储存了自定义标识符的名称，数据类型，和指向类型表的指针；对于常量，另外储存了一个指向常量表的指针，对于变量，储存了一个指向内存单元的指针，对于数组则指向一个数组表，此外还有一个指向下一个标识符单元的指针next。符号表提供了对三种基本数据类型标识符以及数组的接口，其中包括标识符填入符号表，查询标识符是否已定义，获取标识符的value，修改标识符的value，查询以及修改数组元素的value，查询标识符的类型等功能。

   ​	常量表是一个自定义的ConstTable类，其中储存的是常量的类型以及常量的值，包括字符型常量，整型常量以及字符串常量，通过构造函数进行初始化赋值。

   ​	类型表是一个自定义的TypeTable类，其中储存的是标识符的类型，以及一个指针，指向数组表，如果标识符不是数组，那么指针的值就被重置为NULL。类型表中的元素通过重载的四个构造函数实现对不同数据类型标识符的初始化以及储存。

   ​	数组表是一个自定义的ArrayTable类，其中储存的是数组的上下界以及数组元素的数据类型，在我们组的文法中，数组下界默认是0。

4. 系统架构

   ​	整体系统前端部分分为词法分析、语法分析、语义分析、四元式生成和符号表五个部分，其中词法分析作为语法分析的扫描器，为语法分析提供token串，然后语法分析检查语法结构的同时，根据翻译文法规定的语义动作，进行四元式的生成，同时将所有声明的自定义标识符填入符号表，在后续使用时通过查询符号表得到所需的信息，最终实现四元式的生成，并进行后续的优化与目标代码生成。

二、出现的问题

​	【问题1】 在符号表的创建过程中，出现了不同的表中成员循环包含或者指向的关系，导致编译始终无法通过，哪怕加上前项声明。

​	【解决方案】 经过仔细思考，绘制各个表之间的关系，对部分成员进行调整，同时申请更多的空间，以复制构造代替指针或引用，用更多的内存空间来换取指针数量的减少，简化各个表之间的关系，最终避免了编译报错的情况。

​	【问题2】 在作为数组名的自定义标识符添加进入符号表的时候，函数形参与原有重载的函数发生冲突，无法正常添加。

​	【解决方案】 经过分析，发现数组名与普通变量名应有另一标志作为区分，随后通过检查原有重载函数发现其实有一个参数是不必要的，也就是记录数据类型的参数，可以通过函数重载来分辨标识符的类型，去掉这个参数，因此就通过这个参数来作为标识符为数组名的标记，实现了数组名的添加。

三、预期计划

​	预计在7月4号完成从词法分析到语义分析的部分所有程序的合并以及联合调试，实现源程序到四元式生成的整个流程。

​	7月5号完成后端部分的任务分工，开始对四元式优化，目标代码生成和目标代码到汇编指令的转换进行学习研究。

​	7月7号完成后端部分的各个模块，进行参数对接，联合调试。

​	7月8号完成整体编译器的联合调试，实现源程序到目标代码生成的整个流程。

​	

附：符号表部分主要函数

class Table{
	public:
		Table();
		void Add_Entry(string,Style,string); // 暂定void 
		void Add_Entry(string,Style,int);
		void Add_Entry(string,Style,char);
		void Add_Entry(string,Style,Category,int);
		//数组 
		bool Is_Entry(string); 
		bool Is_Array(string);
		
		Category Get_Category(string);
		Style Get_Style(string);
		 
		int Get_Value_Int(string);
		char Get_Value_Char(string);
		string Get_Value_String(string);
		int Get_Array_Value_Int(string,int);
		char Get_Array_Value_Char(string,int);
		string Get_Array_Value_String(string,int);
		
		bool Set_Value(string,int);
		bool Set_Value(string,char);
		bool Set_Value(string,string);
		bool Set_Array_Value(string,int,int);
		bool Set_Array_Value(string,int,char);
		bool Set_Array_Value(string,int,string);
		
		SymbolTable* st;
};